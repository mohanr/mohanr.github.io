---
layout: post
title: Bitcask
published: false
---

{% highlight ocaml %}
open Base
open Checkseum
open Stdlib


type entry = {
    mutable checksum : int32;
	key      : Bytes.t list;
	value    : Bytes.t list
}

let entry key (value : Bytes.t list ) =
    let rec bytes_concat final_bytes v =
      match v with
      | [] -> final_bytes
      | hd :: tl -> bytes_concat (Bytes.cat final_bytes hd) tl
    in
    let final_bytes = bytes_concat Bytes.empty value
    in

    let new_entry = {
        checksum = Crc32.to_int32 (Crc32.digest_bytes final_bytes 0 (Bytes.length final_bytes) Crc32.default)  ;
		key = key;
		value = value;
	}
    in
    new_entry

{% endhighlight %}

# Adaptive Radix Tree

{% highlight ocaml %}


module type Iterator =
sig
  val has_next: 'n list -> bool
  (* val next : 'n *)

end

	type node4 = int
    [@@deriving show]
	type node16 = int
    [@@deriving show]
	type node48 = int
    [@@deriving show]
	type node256 = int
    [@@deriving show]
	type leaf = int
    [@@deriving show]

 module RADIX ( Iter : Iterator ) = struct
    type meta =
    | Prefix of (Bytes.t list)  * int * int
    [@@deriving show]
    and
	leaf_node =
		Key of Bytes.t list
    and
	inner_node =
		meta *
		int *
		Bytes.t list *
		children
    and
    node_type =
      Node4 of node4
    | Node16 of node16
    | Node48 of node48
    | Node256 of node256
    | Leaf of leaf
    [@@deriving show]
    and
	node =
	  | Inner_node of inner_node
	  | Leaf of leaf_node
      | Empty
    [@@deriving show]
    and
	level =
		Node of  node *
		int
    [@@deriving show]
    and
	iterator =
		Tree of  tree *
		node *
		int *
		level list
    and
	tree =
		Root of node
    and
    children = node CCArray.t
      [@printer
        fun fmt arr -> fprintf fmt "%a" (CCArray.pp pp_node) arr]
    [@@deriving show] (* only one call to `deriving show` is not enough *)


	let node4 = 0
	let  node16 = 1
	let  node48 = 2
	let  node256 = 3
	let leaf = 44

	let  node4min = 2
	let  node4max = 4

	let  node16min = node4max + 1
	let  node16max = 16

	let  node48min = node16max + 1
	let node48max = 48

	let node256min = node48max + 1
	let node256max = 256

	let maxprefixlen = 10

	let nullIdx = -1

let char_list_to_byte_list cl =
    let bl  = [] in
    List.map ( fun c ->   bl @ [(Bytes.init 1 ( fun _ -> c )  )]) cl

let make_node_list nodemax=
  let rec loop_while node_list j_dx =
      if j_dx < nodemax then(
		let b = Bytes.create maxprefixlen |> Bytes.to_seq |> List.of_seq in
		let b1 = Bytes.create node4max |> Bytes.to_seq |> List.of_seq in
	    let inn = (
		 Prefix((List.map List.hd (char_list_to_byte_list b)), 0 , 0), (*  Redundant *)
		 nodemax,
         List.map List.hd (char_list_to_byte_list b1),
         CCArray.make nodemax Empty
		 ) in
		loop_while (node_list @ [Inner_node inn]) (j_dx + 1 );
      ) else CCArray.of_list node_list
  in
  loop_while [] 0

let new_node4 node =

	let b = Bytes.create maxprefixlen |> Bytes.to_seq |> List.of_seq in
	let b1 = Bytes.create node4max |> Bytes.to_seq |> List.of_seq in
	let inn = (
		 Prefix((List.map List.hd (char_list_to_byte_list b)), 0 , 0), (*  Redundant *)
		 node4,
         List.map List.hd (char_list_to_byte_list b1),
		 make_node_list node4max)
	in
	Inner_node inn

end
module RADIXOp =
RADIX(struct

  let  has_next l=
     true


 end)
{% endhighlight %}

![Screenshot 2025-06-10 at 10 31 45â€¯PM](https://github.com/user-attachments/assets/dd138d58-c40e-4059-9d70-1b1a9a937680)

