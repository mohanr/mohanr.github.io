---
layout: post
title: Bitcask
published: true
---

{% highlight ocaml %}
open Base
open Checkseum
open Stdlib


type entry = {
    mutable checksum : int32;
	key      : Bytes.t list;
	value    : Bytes.t list
}

let entry key (value : Bytes.t list ) =
    let rec bytes_concat final_bytes v =
      match v with
      | [] -> final_bytes
      | hd :: tl -> bytes_concat (Bytes.cat final_bytes hd) tl
    in
    let final_bytes = bytes_concat Bytes.empty value
    in

    let new_entry = {
        checksum = Crc32.to_int32 (Crc32.digest_bytes final_bytes 0 (Bytes.length final_bytes) Crc32.default)  ;
		key = key;
		value = value;
	}
    in
    new_entry

{% endhighlight %}

# Adaptive Radix Tree

{% highlight ocaml %}



module type Iterator =
sig
  val has_next: 'n list -> bool
  (* val next : 'n *)

end


 module RADIX ( Iter : Iterator ) = struct
    type meta =
    | Prefix of (Bytes.t list)  * int * int
    [@@deriving show]
    and
	leaf_node =
		Key of Bytes.t list
    and
	inner_node =
		meta *
		node_type *
		Bytes.t list *
		children
    and
    node_type =
      Node4 of int
    | Node16 of int
    | Node48 of int
    | Node256 of int
    | Leaf of int
    and
	node =
	  | Inner_node of inner_node
	  | Leaf of leaf_node
      | Empty
    and
	level =
		Node of  node *
		int
    and
	iterator =
		Tree of  tree *
		node *
		int *
		level list
    and
	tree =
		Root of node
    and
    children = node CCArray.t
      (* [@printer *)
      (*   fun fmt arr -> fprintf fmt "%a" (CCArray.pp pp_node) arr] *)
    [@@deriving show] (* only one call to `deriving show` is not enough *)


	let node4 = 0
	let  node16 = 1
	let  node48 = 2
	let  node256 = 3
	let leaf = 44

	let  node4min = 2
	let  node4max = 4

	let  node16min = node4max + 1
	let  node16max = 16

	let  node48min = node16max + 1
	let node48max = 48

	let node256min = node48max + 1
	let node256max = 256

	let maxprefixlen = 10

	let nullIdx = -1

let char_list_to_byte_list cl =
    let bl  = [] in
    List.map ( fun c ->   bl @ [(Bytes.init 1 ( fun _ -> c )  )]) cl

let make_node_list nodemax node_type =
  let rec loop_while node_list j_dx =
      if j_dx < nodemax then(
		let b = Bytes.create maxprefixlen |> Bytes.to_seq |> List.of_seq in
		let b1 = Bytes.create node4max |> Bytes.to_seq |> List.of_seq in
	    let inn = (
		 Prefix((List.map List.hd (char_list_to_byte_list b)), 0 , 0), (*  Redundant *)
		 node_type,
         List.map List.hd (char_list_to_byte_list b1),
         CCArray.make nodemax Empty
		 ) in
		loop_while (node_list @ [Inner_node inn]) (j_dx + 1 );
      ) else CCArray.of_list node_list
  in
  loop_while [] 0

let new_node4 node =

	let b = Bytes.create maxprefixlen |> Bytes.to_seq |> List.of_seq in
	let b1 = Bytes.create node4max |> Bytes.to_seq |> List.of_seq in
	let inn = (
		 Prefix((List.map List.hd (char_list_to_byte_list b)), 0 , 0), (*  Redundant *)
		 Node4 node4,
         List.map List.hd (char_list_to_byte_list b1),
		 make_node_list node4max (Node4 node4))
	in
	Inner_node inn

let grow (n : inner_node ) =
	match n with
	  | ( meta, node_type, keys, children ) ->
	   match node_type with
       | node4 ->
	    let inn = (
		 meta,
		 Node16 node16,
         keys,
         children)
	    in
	    Inner_node inn

	| node16 ->     (*Create a Node48 and set values  *)
         match meta with
          | Prefix (l, i1, i2) ->
           let index = i1 in
           let rec loop_while j_dx index =
            if j_dx < i1  then(
			 let child = Array.get children j_dx in
			 match child with
               | Empty -> loop_while ( j_dx + 1 ) ( index + 1 )
               | _ ->
                let k = List.mapi (fun i el -> if i = j_dx then
                                         (List.nth keys (index + 1))
                                         else el) keys in (* TODO Array is mutable and needed here*)
                let c = Array.set children index in
                loop_while ( j_dx + 1 ) ( index + 1 );
           ) else(
	            let inn = (
		         meta,
		         Node48 node48,
                 keys,
                 children)
	            in
	            Inner_node inn
           )
          in
          loop_while 0 index;
end

module RADIXOp =
RADIX(struct

  let  has_next l=
     true


 end)
{% endhighlight %}

![Screenshot 2025-06-10 at 10 31 45â€¯PM](https://github.com/user-attachments/assets/dd138d58-c40e-4059-9d70-1b1a9a937680)

