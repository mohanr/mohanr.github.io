---
layout: post
title: Bitcask
published: false
---

{% highlight ocaml %}
open Base
open Checkseum
open Stdlib


type entry = {
    mutable checksum : int32;
	key      : Bytes.t list;
	value    : Bytes.t list
}

let entry key (value : Bytes.t list ) =
    let rec bytes_concat final_bytes v =
      match v with
      | [] -> final_bytes
      | hd :: tl -> bytes_concat (Bytes.cat final_bytes hd) tl
    in
    let final_bytes = bytes_concat Bytes.empty value
    in

    let new_entry = {
        checksum = Crc32.to_int32 (Crc32.digest_bytes final_bytes 0 (Bytes.length final_bytes) Crc32.default)  ;
		key = key;
		value = value;
	}
    in
    new_entry

{% endhighlight %}

# Adaptive Radix Tree

{% highlight ocaml %}

module type Iterator =
sig
  val has_next: 'n list -> bool
  val next : 'n
end

 module RADIX ( Iter : Iterator ) = struct

	type node4 = int
	type node16 = int
	type node48 = int
	type node256 = int
	type leaf = int
    type 'i meta =
    | Prefix of (Bytes.t list)  * int * int
    and
	'i leaf_node =
		Key of Bytes.t list *
		'i
    and
	'i inner_node =
		'i meta *
		int *
		Bytes.t list *
		'i children
    and
    node_type =
      Node4 of node4
    | Node16 of node16
    | Node48 of node48
    | Node256 of node256
    | Leaf of leaf
    and
	'i node =
	  | Inner_node of 'i inner_node
	  | Leaf of 'i leaf_node
    and
	'i level =
		Node of 'i node *
		int
    and
	'i iterator =
		Tree of 'i tree *
		'i node *
		int *
		'i level list
    and
	'i tree =
		Root of 'i node
    and
    'i children = 'i node Array.t



	let node4 = 0
	let  node16 = 1
	let  node48 = 2
	let  node256 = 3
	let leaf = 4

	let  node4min = 2
	let  node4max = 4

	let  node16min = node4max + 1
	let  node16max = 16

	let  node48min = node16max + 1
	let node48max = 48

	let node256min = node48max + 1
	let node256max = 256

	let maxprefixlen = 10

	let nullIdx = -1

let rec make_node_list nodes_list nodemax=
  let char_list_to_byte_list cl =
    let bl  = [] in
    List.map ( fun c ->   bl @ [(Bytes.init 1 ( fun _ -> c )  )]) cl
  in
  let rec make nodes =
    match nodes with
      | [] -> []
      | hd::l ->
		let b = Bytes.create maxprefixlen |> Bytes.to_seq |> List.of_seq in
	    let inn = (
		 Prefix((List.map List.hd (char_list_to_byte_list b)), 0 , 0),
		 node4,
		 Bytes.create node4max,
		 make_node_list node4max)
        in  inn :: make l;
    in  (make_node_list nodes_list nodemax)

{% endhighlight %}
